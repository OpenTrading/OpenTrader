# -*-mode: python; py-indent-offset: 4; indent-tabs-mode: nil; encoding: utf-8-dos; coding: utf-8 -*-

"""

   ``PyTables`` will show a ``NaturalNameWarning`` if a  column name
   cannot be used as an attribute selector. Generally identifiers that
   have spaces, start with numbers, or ``_``, or have ``-`` embedded are not considered
   *natural*. These types of identifiers cannot be used in a ``where`` clause
   and are generally a bad idea.

"""

import sys
import os
from collections import OrderedDict
import pandas

from PandasMt4 import oReadMt4Csv

class Omlette(object):
    __fOmleteVersion__ = 1.0
    
    def __init__(self, sHdfStore="", oFd=sys.stdout):
        self.oHdfStore = None
        if sHdfStore:
            self.oHdfStore = pandas.HDFStore(sHdfStore, mode='w')
            oFd.write("INFO: hdf store" +self.oHdfStore.filename +'\n')

        self.oFd = oFd
        self.oRecipe = None
        self.ChefModule = None

    def oRestore(self, sHdfStore):
        assert os.path.exists(sHdfStore)
        self.oHdfStore = None
        return self.oHdfStore
        
    # is this an Omlette method? its generic and the use of self is tangential
    def dGetFeedFrame(self, sCsvFile, sTimeFrame, sSymbol, sYear):
        dFeedParams = OrderedDict(sTimeFrame=sTimeFrame, sSymbol=sSymbol, sYear=sYear)
        dFeedParams['mFeedOhlc'] = oReadMt4Csv(sCsvFile, **dFeedParams)
        dFeedParams['open_label'] = 'O'
        dFeedParams['close_label'] = 'C'
        dFeedParams['sKey'] = sSymbol + sTimeFrame + sYear
        dFeedParams['sCsvFile'] = sCsvFile

        self.vAppendHdf('feed/mt4/' +dFeedParams['sKey'],
                        dFeedParams['mFeedOhlc'])
        dMetadata = dFeedParams.copy()
        del dMetadata['mFeedOhlc']        
        self.vSetMetadataHdf('feed/mt4/' +dFeedParams['sKey'], dMetadata)
        self.vSetTitleHdf('feed/mt4', 'Mt4')
        self.vSetTitleHdf('feed', 'Feeds')
        return dFeedParams
    
    def oAddRecipe(self, sRecipe):
        OmlettesPkg = __import__('Omlettes.'+sRecipe)
        RecipeModule = getattr(OmlettesPkg, sRecipe)
        RecipeKlass = getattr(RecipeModule, sRecipe)
        self.oRecipe = RecipeKlass()
        if not self.oRecipe.sName:
            self.oRecipe.sName = sRecipe
        if not self.oRecipe.sFile:
            self.oRecipe.sFile = RecipeModule.__file__
        self.oRecipe.oOm = self
        return self.oRecipe
    
    def oAddChef(self, sChef):
        OmlettesPkg = __import__('Omlettes.'+sChef)
        self.ChefModule = getattr(OmlettesPkg, sChef)
        self.sChef = sChef
        return self.ChefModule
    
    def dMakeChefsParams(self, **dKw):
        self.dChefsParams = OrderedDict(**dKw)
        return self.dChefsParams
    
    def vSetTitleHdf(self, sKey, sData):
        oHdfStore = self.oHdfStore
        if oHdfStore is None: return
        self.oHdfStore.get_node(sKey)._g_settitle(sData)

    def vSetMetadataHdf(self, sKey, gData):
        oHdfStore = self.oHdfStore
        if oHdfStore is None: return
        self.vAppendHdf(sKey, None, gData)

    def vAppendHdf(self, sKey, gData, gMetaData=None):
        oHdfStore = self.oHdfStore
        if oHdfStore is None: return
        
        if gData is None:
            # we need to check if the key exists
            pass
            # drop through
        # assert sCat in ['recipe', 'feed'], "ERROR: unrecognized category: " +sCat
        elif type(gData) in [pandas.Series, pandas.DataFrame, pandas.Panel]:
            self.oFd.write("INFO: HDF putting " +sKey +'\n')
            oHdfStore.put('/' +sKey, gData,
                          format='table',
                          data_columns=True)
            oHdfStore.flush()
        else:
            self.oFd.write("ERROR: unsupported datatype for %s: %r \n" % \
                           (sKey, type(gData),))
            return
        
        if gMetaData is None:
            return
        if type(gMetaData) in [dict, OrderedDict]:
            # o = getattr(getattr(oHdfStore.root, sCat), sInst)
            o = oHdfStore.get_node('/'+sKey)
            o._v_attrs.metadata = [gMetaData]
            oHdfStore.flush()

    def vClose(self):
        if self.oHdfStore is None: return
        self.oFd.write("INFO: closing hdf " +repr(self.oHdfStore) +'\n')
        self.oHdfStore.close()
        self.oHdfStore = None

def iMain():
    """
    Read an hdf file generated by us to make sure
    we can recover its content and structure.
    Give the name of an hdf5 file as a command-line argument.
    """
    assert sys.argv, __doc__
    sFile = sys.argv[1]
    assert os.path.isfile(sFile)
    oHdfStore = pandas.HDFStore(sFile, mode='r')
    print oHdfStore.groups()
    # bug - no return value
    # oSignals = pandas.read_hdf(oHdfStore, '/servings/signals')
    mSignals = oHdfStore.select('/recipe/servings/mSignals', auto_close=False)    
    print mSignals
    print oHdfStore.get_node('/recipe')._v_attrs.metadata[0]['sUrl']
    
if __name__ == '__main__':
    iMain()
